<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sentient Tower — Pink Stack</title>
<style>
  :root{
    --bg1:#070717;
    --bg2:#0f0620;
    --panel:#071026;
    --pink:#ff5aa3;
    --pink-dark:#e64a8f;
    --muted:rgba(255,255,255,0.08);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e9f6ff}
  body{
    background: linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 100%);
    display:flex;align-items:center;justify-content:center;padding:20px;
  }
  .game-wrap{width:100%;max-width:520px;}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{font-size:18px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.primary{background:var(--pink);border:none;color:#111}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:12px}
  #game{
    background:linear-gradient(180deg,#041028 0%, #00121a 100%);
    border-radius:10px; height:640px; position:relative; overflow:hidden; box-shadow: 0 8px 30px rgba(5,5,12,0.7);
    display:flex;flex-direction:column;
  }
  canvas{width:100%;height:100%;display:block}
  .hud{display:flex;justify-content:space-between;padding:10px 12px}
  .stat{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:8px;font-size:14px}
  .hint{font-size:13px;color:#9ecae7}
  .footer{padding:10px 12px;color: #9fc7de;font-size:13px}
  .bigcenter{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;
  }
  .btn-large{padding:10px 14px;border-radius:10px}
  @media(max-width:420px){ #game{height:560px} }
</style>
</head>
<body>
  <div class="game-wrap">
    <header>
      <h1>Sentient Tower — Pink Stack</h1>
      <div class="controls">
        <div class="hint">Tap / Click / Space to stop</div>
      </div>
    </header>

    <div class="card">
      <div class="hud">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Best: <span id="best">0</span></div>
        <div class="stat">Level: <span id="level">1</span></div>
      </div>

      <div id="game">
        <canvas id="c"></canvas>

        <div id="overlayStart" class="bigcenter" style="display:flex;flex-direction:column;gap:8px">
          <div style="font-size:20px">Tap to Start</div>
          <button id="startBtn" class="primary btn-large">Start Game</button>
          <div style="font-size:13px;color:#9fc7de;margin-top:6px">Blocks are pink; thin slices remain solid pink.</div>
        </div>

        <div id="overlayGameOver" class="bigcenter" style="display:none">
          <div style="font-size:26px">Game Over</div>
          <div style="margin-top:6px;font-size:16px">Score: <span id="finalScore">0</span></div>
          <div style="margin-top:12px;display:flex;gap:8px">
            <button id="retryBtn" class="btn-large">Retry</button>
            <button id="homeBtn" class="btn-large">Home</button>
          </div>
        </div>
      </div>

      <div class="footer">Use left / right arrows to nudge while the block is sliding. If overlap becomes too small — game ends.</div>
    </div>
  </div>

<script>
/*
  Sentient Tower — Pink Stack
  - Sliding block moves horizontally; click/space/tap to stop and slice to previous.
  - If overlap <= 0 -> game over.
  - If resulting slice is very thin (<= MIN_VISIBLE), it's still shown as solid pink (no images).
  - Includes score, best (localStorage), level (difficulty increases).
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * devicePixelRatio);
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resize);
resize();

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const levelEl = document.getElementById('level');
const overlayStart = document.getElementById('overlayStart');
const overlayGameOver = document.getElementById('overlayGameOver');
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const homeBtn = document.getElementById('homeBtn');
const finalScore = document.getElementById('finalScore');

let best = parseInt(localStorage.getItem('sentient_tower_best')||'0', 10);
bestEl.textContent = best;

const PINK = '#ff5aa3';
const PINK_DARK = '#e64a8f';
const SHADOW = 'rgba(0,0,0,0.35)';

const GAME_W = 360; // logical width for layouting (we will scale)
let scale = 1;

const STATE = {
  blocks: [], // stacked blocks (from bottom -> top)
  moving: null, // current moving block object
  score: 0,
  running: false,
  level: 1,
  speed: 160, // px/sec base (scaled)
  minVisible: 18, // px (if slice <= this, still pink but visible)
  lastTime: 0,
  direction: 1,
};

// Utility: create a block object
function makeBlock(x, y, w, h, color){
  return { x, y, w, h, color, vx:0, sliding:false };
}

// Initialize / Start game
function startGame(){
  // scale depends on canvas width
  const cw = canvas.getBoundingClientRect().width;
  scale = cw / GAME_W;

  STATE.blocks = [];
  STATE.score = 0;
  STATE.level = 1;
  STATE.speed = 160;
  STATE.running = true;
  STATE.lastTime = performance.now();
  STATE.direction = 1;

  // create ground block (base) centered
  const initialW = 220 * scale;
  const groundW = Math.min(cw - 20, initialW);
  const groundH = 36 * scale;
  const baseX = cw/2;
  const baseY = canvas.getBoundingClientRect().height - groundH/2 - 10;
  STATE.blocks.push(makeBlock(baseX, baseY, groundW, groundH, PINK_DARK));
  spawnMovingBlock();

  scoreEl.textContent = STATE.score;
  levelEl.textContent = STATE.level;
  overlayStart.style.display = 'none';
  overlayGameOver.style.display = 'none';
}

// Spawn the sliding block at the top of the current tower
function spawnMovingBlock(){
  const top = STATE.blocks[STATE.blocks.length - 1];
  const blockW = top.w;
  const blockH = top.h;
  const spawnY = top.y - top.h - 10;
  // start from left edge outside the canvas
  const cw = canvas.getBoundingClientRect().width;
  const startX = -blockW/2;
  const b = makeBlock(startX, spawnY, blockW, blockH, PINK);
  b.sliding = true;
  b.vx = STATE.speed * STATE.direction; // px/sec (unscaled since canvas uses CSS units)
  STATE.moving = b;
}

// Stop the sliding block and slice
function stopBlock(){
  if(!STATE.running || !STATE.moving) return;
  const top = STATE.blocks[STATE.blocks.length - 1];
  const cur = STATE.moving;

  // compute overlap in x (axis-aligned)
  const leftA = cur.x - cur.w/2;
  const rightA = cur.x + cur.w/2;
  const leftB = top.x - top.w/2;
  const rightB = top.x + top.w/2;
  const overlap = Math.max(0, Math.min(rightA,rightB) - Math.max(leftA,leftB));

  if(overlap <= 0){
    // miss => game over
    endGame();
    return;
  }

  // center of overlapped piece
  const overlapLeft = Math.max(leftA,leftB);
  const overlapRight = Math.min(rightA,rightB);
  const overlapCenter = (overlapLeft + overlapRight)/2;

  // left cut width and right cut width
  const leftCut = overlapLeft - leftA;
  const rightCut = rightA - overlapRight;

  // push the overlapped part as new stack piece
  const newW = overlap;
  const newX = overlapCenter;
  const newY = cur.y;
  const newBlock = makeBlock(newX, newY, newW, cur.h, PINK);
  newBlock.sliding = false;
  STATE.blocks.push(newBlock);

  // update score, level, speed
  STATE.score += 1;
  if(STATE.score % 6 === 0){ STATE.level += 1; STATE.speed += 22; }

  // create falling pieces for leftCut and rightCut (if any) and animate them
  const fallingPieces = [];
  if(leftCut > 0.5){
    const w = leftCut;
    const x = (leftA + overlapLeft)/2;
    fallingPieces.push({ x, y:cur.y, w, h:cur.h, vx:-80 + Math.random()*-40, vy: 30 + Math.random()*60, rot: (Math.random()-0.5)*0.6 });
  }
  if(rightCut > 0.5){
    const w = rightCut;
    const x = (overlapRight + rightA)/2;
    fallingPieces.push({ x, y:cur.y, w, h:cur.h, vx: 80 + Math.random()*40, vy: 30 + Math.random()*60, rot: (Math.random()-0.5)*0.6 });
  }

  // if the resulting part is tiny but >0, keep it (still pink). If <= 0, game over handled above.
  // Increase difficulty: slightly shrink width of next moving block based on level to make it harder (optional)
  // spawn the next moving block aligned to the left side for variety
  STATE.moving = null;

  // animate falling pieces: attach to state for render loop
  STATE.fallingPieces = STATE.fallingPieces || [];
  STATE.fallingPieces.push(...fallingPieces);

  // move camera up (we simulate by shifting y of all blocks down a bit to give stacking upward illusion)
  // We'll animate a small upward camera effect by shifting all blocks downward visually
  shiftTowerUp(newBlock.h + 6);

  // update UI
  scoreEl.textContent = STATE.score;
  levelEl.textContent = STATE.level;
  if(STATE.score > best){ best = STATE.score; localStorage.setItem('sentient_tower_best', String(best)); bestEl.textContent = best; }

  // spawn next block after a tiny delay for UX
  setTimeout(()=>{ spawnMovingBlock(); }, 180);
}

function shiftTowerUp(deltaY){
  // Move all existing blocks down by deltaY (so new block appears higher)
  for(let b of STATE.blocks){
    b.y += deltaY;
  }
  // Also adjust falling pieces if any
  if(STATE.fallingPieces){
    for(let f of STATE.fallingPieces) f.y += deltaY;
  }
}

function endGame(){
  STATE.running = false;
  finalScore.textContent = STATE.score;
  overlayGameOver.style.display = 'flex';
  // small topple: turn moving into falling piece if exists
  if(STATE.moving){
    STATE.fallingPieces = STATE.fallingPieces || [];
    STATE.fallingPieces.push({ x: STATE.moving.x, y: STATE.moving.y, w: STATE.moving.w, h: STATE.moving.h, vx: (Math.random()>0.5?120:-120), vy: -40, rot: (Math.random()-0.5)*1.2 });
    STATE.moving = null;
  }
}

// Render loop
function draw(){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;
  ctx.clearRect(0,0,W,H);

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, 'rgba(8,12,30,0.9)');
  g.addColorStop(1, 'rgba(0,8,14,0.9)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // subtle horizon line
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,H-12,W,12);

  // draw stacked blocks (bottom -> top)
  for(let i=0;i<STATE.blocks.length;i++){
    const b = STATE.blocks[i];
    drawBlock(b);
  }

  // draw falling pieces
  if(STATE.fallingPieces){
    for(let i=STATE.fallingPieces.length-1;i>=0;i--){
      const p = STATE.fallingPieces[i];
      drawFallingPiece(p);
    }
  }

  // draw moving block
  if(STATE.moving){
    drawBlock(STATE.moving, true);
  }
}

// draw a block with shadow and slight 3D effect
function drawBlock(b, isMoving=false){
  const ctxX = b.x; const ctxY = b.y; const w = b.w; const h = b.h;
  // drop shadow
  ctx.save();
  ctx.fillStyle = SHADOW;
  ctx.beginPath();
  ctx.ellipse(ctxX, ctxY + h*0.4, w*0.52, h*0.28, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // block rect with gradient
  ctx.save();
  const grad = ctx.createLinearGradient(ctxX - w/2, ctxY - h/2, ctxX + w/2, ctxY + h/2);
  grad.addColorStop(0, (isMoving ? '#ff6ab4' : '#ff5aa3'));
  grad.addColorStop(1, (isMoving ? '#ff3f90' : '#e64a8f'));
  ctx.fillStyle = grad;
  // rounded rect
  roundRect(ctx, ctxX - w/2, ctxY - h/2, w, h, Math.min(12, h*0.25));
  ctx.fill();

  // top highlight
  ctx.globalAlpha = 0.12;
  roundRect(ctx, ctxX - w/2 + 2, ctxY - h/2 + 2, w - 4, h/2 - 4, Math.min(10, h*0.2));
  ctx.fillStyle = 'white';
  ctx.fill();
  ctx.globalAlpha = 1.0;

  // thin border
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  roundRect(ctx, ctxX - w/2, ctxY - h/2, w, h, Math.min(12, h*0.25));
  ctx.stroke();

  ctx.restore();
}

// simple rounded rect helper (path only)
function roundRect(ctx, x, y, w, h, r){
  const radius = r;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + w, y, x + w, y + h, radius);
  ctx.arcTo(x + w, y + h, x, y + h, radius);
  ctx.arcTo(x, y + h, x, y, radius);
  ctx.arcTo(x, y, x + w, y, radius);
  ctx.closePath();
}

// draw falling trimmed piece (rotating, gravity)
function drawFallingPiece(p){
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rot || 0);
  const grad = ctx.createLinearGradient(-p.w/2, -p.h/2, p.w/2, p.h/2);
  grad.addColorStop(0, PINK);
  grad.addColorStop(1, PINK_DARK);
  ctx.fillStyle = grad;
  roundRect(ctx, -p.w/2, -p.h/2, p.w, p.h, Math.min(10, p.h*0.25));
  ctx.fill();
  ctx.restore();
}

// physics update loop
function tick(now){
  if(!STATE.running){
    draw();
    requestAnimationFrame(tick);
    return;
  }
  const dt = Math.min(0.033, (now - STATE.lastTime)/1000);
  STATE.lastTime = now;

  const rect = canvas.getBoundingClientRect();
  const W = rect.width;

  // update moving block position (sliding left-right)
  if(STATE.moving && STATE.moving.sliding){
    const m = STATE.moving;
    m.x += m.vx * dt;
    // bounce at edges
    const halfW = m.w / 2;
    if(m.x - halfW < 6){ m.x = halfW + 6; m.vx *= -1; }
    if(m.x + halfW > W - 6){ m.x = W - halfW - 6; m.vx *= -1; }
    // allow keyboard nudge (small)
    if(STATE.nudgeLeft) m.x -= 160 * dt;
    if(STATE.nudgeRight) m.x += 160 * dt;
  }

  // update falling pieces physics
  if(STATE.fallingPieces){
    for(let i=STATE.fallingPieces.length-1;i>=0;i--){
      const p = STATE.fallingPieces[i];
      p.vy += 1200 * dt; // gravity
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rot += (Math.random()-0.5) * 0.05;
      // remove if off screen
      if(p.y > rect.height + 200) STATE.fallingPieces.splice(i,1);
    }
  }

  draw();
  requestAnimationFrame(tick);
}

// Input handling
window.addEventListener('keydown', (e)=>{
  if(e.code === 'Space'){ e.preventDefault(); if(!STATE.running){ startGame(); } else { stopBlock(); } }
  if(e.code === 'ArrowLeft'){ STATE.nudgeLeft = true; }
  if(e.code === 'ArrowRight'){ STATE.nudgeRight = true; }
});
window.addEventListener('keyup', (e)=>{
  if(e.code === 'ArrowLeft'){ STATE.nudgeLeft = false; }
  if(e.code === 'ArrowRight'){ STATE.nudgeRight = false; }
});

canvas.addEventListener('click', ()=>{
  if(!STATE.running){ startGame(); } else { stopBlock(); }
});
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(!STATE.running){ startGame(); } else { stopBlock(); } }, {passive:false});

// Buttons
startBtn.addEventListener('click', startGame);
retryBtn.addEventListener('click', ()=>{
  overlayGameOver.style.display = 'none';
  startGame();
});
homeBtn.addEventListener('click', ()=>{
  overlayGameOver.style.display = 'none';
  overlayStart.style.display = 'flex';
});

// initial setup: create base block visualization (no game running)
(function initStaticBase(){
  const cw = canvas.getBoundingClientRect().width;
  const rect = canvas.getBoundingClientRect();
  const initialW = Math.min(cw - 20, 220);
  const baseH = 36;
  const baseX = cw/2;
  const baseY = rect.height - baseH/2 - 10;
  STATE.blocks = [ makeBlock(baseX, baseY, initialW, baseH, PINK_DARK) ];
  draw();
})();

// start the animation loop
requestAnimationFrame((t)=>{ STATE.lastTime = t; requestAnimationFrame(tick); });
</script>
</body>
</html>
